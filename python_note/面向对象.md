# Python Note

***

## 对象定义

1. 对象是内存中数据存储的区域
2. 对象中可存储多种数据（如：数字、布尔值、代码）
3. 对象的构成：标识（id）、类型（type）、值（value）

## 面向对象

    - python是面向对象的编程语言
    - 所谓面向对象，指的是语言中的操作，都是基于对象进行的。
    - 面向过程的编程语言：指我们将程序逻辑分解为多个步骤，通过对步骤的抽象完成程序。缺点->往往只能适应于单一功能，面临其他需求时，需要重新编写代码。优点->编写简单，与人类思维习惯相近。编程特点->复用性低，难于维护。
    - 面向对象的编程语言：将功能保存到对象中，易读，并且复用性较强，但不符合常规思维，编写开发具有难度。
    
## 类（class）
    - 对象都有 id type value，而类也具备这一特征，使用id(MyClass)、type(MyClass) ,均可以得到值，类是用来创建对象的对象。
    - python中内嵌多种内嵌对象，便于python开发，但在开发中是远远不够的，需要开发自定义对象。类相当于自定义对象的图纸，基于图纸内容创建类。
    - 若多个对象通过一个类创建，那么称之为一类对象。（例如：int()、float()...，python自有类使用小写，自定义类需要大写首字母。）
    
### 定义规则

使用大驼峰法命名，并首字母大写。

### 特征

使用类创造的对象都是空对象，可以在对象内添加变量。

对象.属性值 = 属性值

```

class MyClass():
    pass

print(MyClass)

# 使用MyClass创建对象
mc = MyClass()

mc.name = '李建刚'

```

### 类创建对象流程

1. 创建变量
2. 在内存中创建新对象
3. 将对象id赋值给变量

### 类的定义

类和对象都是对现实生活中或程序中内容的抽象。
所有的事物都是由两部分构成：
1. 数据（属性）
2. 行为（方法）
```

class Person():
    name = '1'

    def fun(self):
        return self


p1 = Person()
p2 = Person()


p1.name = 'zbj'
del p1.name
print(p1.name)

```

需共享属性或方法保存到类中，实例独有的保存到实例属性中。

通常情况下，方法多保存至类中，属性多以属性写到实例中。

当使用del删除实例属性后，会直接读取构成实例的类方法默认值。

类中的方法中，不能直接使用类域下的属性，需要使用self.属性名将域作为参数传递使用。

p = Person()运行过程中
1. 创建变量
2. 在内存中创建新对象
3. __init__(self)方法执行
4. 对象id赋值给变量
init会在对象创建后，立刻执行，初始化属性，实际操作实例对象。
```python
class Dog:

    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender

    def wolf(self):
        print(self.name + ':汪汪汪')


dog = Dog('aw', 20, 'male')
dog.wolf()
```
数据修改限制：

封装是面向对象的三大特性之一，

隐藏不希望被外部访问的属性或方法，
1. 将内部属性名改为外部不知道的名字，

```python
class Dog:

    def __init__(self, name):
        self.hidden_name = name

    def wolf(self):
        print('大家好，我是 %s'%self.hidden_name)


dog = Dog('阿福')
dog.wolf()
```

2. 获取隐藏属性

提供getter、setter可以令外界访问到内部属性

```python
class Dog:

    def __init__(self, name):
        self.hidden_name = name

    def wolf(self):
        print('大家好，我是 %s'%self.hidden_name)
    
    def get_name(self):
        return self.hidden_name
    
    def set_name(self, name):
        self.hidden_name = name

dog = Dog('阿福')
dog.set_name('小猪')
dog.wolf()
```

使用封装之后，提高了数据安全性。使用时不能任意修改属性，可添加判断过滤条件，对属性内容的设置进行限制。

如果希望属性不被外部操作，可以直接去掉对应getter、setter方法

可以添加双下划线添加隐藏属性，这样外层无法访问，即使知道隐藏属性前缀，也无法修改类内部属性，但是隐藏的背后可以添加_Person__name更改，添加隐藏字符串头部（实质是python添加的隐藏头部）。

常规使用，隐藏属性会使用_name，仅添加单下划线示意不希望修改。
```
class Person:
    def __init__(self, name):
        self.__name = name
    def get_name(self):
        return self.__name

p = Person('张三')
p._Person__name = '张四'

print(p.get_name())
```

### @property装饰器
```
class Person:
    def __init__(self, name):
        self._name = name
    
    def name(self):
        print('get方法执行了')
        return self._name
p = Person('阿肆')
print(p.name())
```
使用@property修饰后，类外方法无法修改内部属性
```
class Person:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        print('get方法执行了')
        return self._name
p = Person('阿肆')
# 点属性无法操作，需要使用类内操作方法更改属性值。
# p.name = '' 
# 直接属性调用
print(p.name)
```
使用@name.setter设置对应设置方法后，可点属性操作设置。
@property相当于getter，使用.setter必须要设置property。
```
class Person:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        print('get方法执行了')
        return self._name
    @name.setter
    def name(self,name):
        print('setter方法调用了')
        self._name = name
p = Person('阿肆')
p.name = '阿伍'
print(p.name)
```
### 类的继承
```
class Animal:
    def run(self):
        print('动物跑')
    def sleep(self):
        print('动物睡觉')

class Dog(Animal):
    def bark(self):
        print('汪汪')

d = Dog()
d.bark()
d.run()
```